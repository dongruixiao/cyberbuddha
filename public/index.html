<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cyber Buddha - x402</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cn-fontsource-kxzd-regular/font.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=ZCOOL+XiaoWei&family=Noto+Serif+SC:wght@200;300&display=swap">
  <style>
    :root {
      --neon-start: #00ff88;
      --neon-end: #00d4ff;
      --neon: #00ff88;
      --neon-dim: #00ff8866;
      --gold: #ffaa00;
      --bg: #0a0a0a;
      --flame: #ff6600;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: var(--bg);
      height: 100vh;
      overflow: hidden;
      display: flex;
      justify-content: center;
      align-items: center;
      font-family: 'Courier New', monospace;
      color: var(--neon);
    }

    .header-left {
      position: fixed;
      top: 0;
      left: 0;
      padding: 12px 16px;
      z-index: 100;
      font-size: 10px;
    }

    .header-right {
      position: fixed;
      top: 0;
      right: 0;
      padding: 12px 16px;
      z-index: 100;
      font-size: 10px;
    }

    .msg-queue {
      position: fixed;
      bottom: 12px;
      left: 16px;
      z-index: 100;
      font-size: 10px;
      display: flex;
      flex-direction: column-reverse;
      gap: 4px;
      max-width: 250px;
    }

    .msg-item {
      opacity: 1;
      transition: opacity 0.5s;
      letter-spacing: 0.5px;
      color: #00ff88;
    }

    .msg-item.error { color: #ff4444; }
    .msg-item.success { color: #00ff88; }

    .cursor { animation: blink 1s infinite; }
    @keyframes blink { 0%, 50% { opacity: 1; } 51%, 100% { opacity: 0; } }

    .wallet-status {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      color: rgba(255, 170, 0, 0.6);
      transition: all 0.2s;
    }
    .wallet-status:hover {
      color: var(--gold);
      text-shadow: 0 0 6px var(--gold);
    }
    .wallet-status.connected {
      color: rgba(0, 255, 136, 0.8);
    }
    .wallet-status.connected:hover {
      color: var(--neon);
      text-shadow: 0 0 6px var(--neon);
    }
    .wallet-status::before {
      content: '';
      width: 6px;
      height: 6px;
      border-radius: 50%;
      animation: dot-pulse-gold 3s ease-in-out infinite;
    }
    .wallet-status.connected::before {
      animation: dot-pulse-green 3s ease-in-out infinite;
    }
    @keyframes dot-pulse-gold {
      0%, 100% { background: rgba(255, 170, 0, 0.35); box-shadow: 0 0 4px rgba(255, 170, 0, 0.2); }
      50% { background: rgba(255, 170, 0, 0.85); box-shadow: 0 0 8px rgba(255, 170, 0, 0.5); }
    }
    @keyframes dot-pulse-green {
      0%, 100% { background: rgba(0, 255, 136, 0.5); box-shadow: 0 0 6px rgba(0, 255, 136, 0.3); }
      50% { background: rgba(0, 255, 136, 1); box-shadow: 0 0 10px rgba(0, 255, 136, 0.7); }
    }

    .chain-switcher {
      display: none;
      align-items: center;
      gap: 4px;
      font-size: 10px;
      user-select: none;
    }
    .chain-switcher.connected {
      display: flex;
    }

    .chain-arrow {
      cursor: pointer;
      padding: 2px 4px;
      transition: all 0.15s;
      animation: arrow-pulse-gold 3s ease-in-out infinite;
    }
    .chain-switcher.connected .chain-arrow {
      animation: arrow-pulse-green 3s ease-in-out infinite;
    }
    @keyframes arrow-pulse-gold {
      0%, 100% { color: rgba(255, 170, 0, 0.25); }
      50% { color: rgba(255, 170, 0, 0.6); }
    }
    @keyframes arrow-pulse-green {
      0%, 100% { color: rgba(0, 255, 136, 0.4); }
      50% { color: rgba(0, 255, 136, 0.8); }
    }

    .chain-arrow:hover {
      color: var(--gold);
      text-shadow: 0 0 8px var(--gold);
      animation: none;
    }
    .chain-switcher.connected .chain-arrow:hover {
      color: var(--neon);
      text-shadow: 0 0 8px var(--neon);
      animation: none;
    }

    .chain-name {
      letter-spacing: 1px;
      min-width: 100px;
      text-align: center;
      cursor: pointer;
      transition: all 0.15s;
      color: rgba(255, 170, 0, 0.55);
    }
    .chain-switcher.connected .chain-name {
      color: rgba(0, 255, 136, 0.7);
    }

    .chain-name:hover {
      color: var(--gold);
      text-shadow: 0 0 6px var(--gold);
    }
    .chain-switcher.connected .chain-name:hover {
      color: var(--neon);
      text-shadow: 0 0 6px var(--neon);
    }

    .wallet-addr {
      font-size: 11px;
      letter-spacing: 1px;
      cursor: pointer;
    }
    .wallet-addr:hover { opacity: 0.7; }

    /* Wallet Modal */
    .wallet-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.8);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    .wallet-modal.show {
      display: flex;
    }
    .wallet-modal-content {
      background: #111;
      border: 1px solid rgba(255, 170, 0, 0.3);
      padding: 24px;
      min-width: 280px;
      box-shadow: 0 0 30px rgba(255, 170, 0, 0.1);
    }
    .wallet-modal-title {
      color: var(--gold);
      font-size: 12px;
      margin-bottom: 20px;
      text-align: center;
      letter-spacing: 2px;
    }
    .wallet-option {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 12px 16px;
      margin-bottom: 8px;
      border: 1px solid rgba(255, 170, 0, 0.2);
      cursor: pointer;
      transition: all 0.2s;
      color: rgba(255, 170, 0, 0.6);
      font-size: 11px;
      letter-spacing: 1px;
    }
    .wallet-option:hover {
      border-color: var(--gold);
      color: var(--gold);
      background: rgba(255, 170, 0, 0.05);
      box-shadow: 0 0 15px rgba(255, 170, 0, 0.1);
    }
    .wallet-option.disabled {
      opacity: 0.3;
      cursor: not-allowed;
    }
    .wallet-option.disabled:hover {
      border-color: rgba(255, 170, 0, 0.2);
      color: rgba(255, 170, 0, 0.6);
      background: transparent;
      box-shadow: none;
    }
    .wallet-icon {
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }
    .wallet-modal-divider {
      height: 1px;
      background: rgba(255, 170, 0, 0.25);
      margin: 16px 0;
    }
    .network-toggle {
      display: flex;
      justify-content: center;
      gap: 20px;
    }
    .network-opt {
      color: rgba(255, 170, 0, 0.35);
      font-size: 10px;
      letter-spacing: 1px;
      cursor: pointer;
      padding: 4px 12px;
      transition: all 0.2s;
    }
    .network-opt:hover {
      color: rgba(255, 170, 0, 0.6);
    }
    .network-opt.selected {
      color: var(--gold);
      text-shadow: 0 0 6px rgba(255, 170, 0, 0.4);
    }

    .container { text-align: center; padding: 10px; }

    .buddha-wrapper {
      position: relative;
      display: inline-block;
    }

    .buddha-light {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 0;
      height: 0;
      border-radius: 50%;
      background: radial-gradient(circle,
        rgba(255, 215, 0, 0.3) 0%,
        rgba(255, 170, 0, 0.15) 40%,
        transparent 70%);
      pointer-events: none;
      opacity: 0;
      z-index: -1;
    }

    /* æ³•è½® Canvas */
    #dharma-canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: -1;
    }

    /* æ¢µéŸ³æ³¢çº¹ Canvas */
    #ripple-canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: -1;
    }

    /* è²èŠ±ç»½æ”¾ Canvas */
    #lotus-canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      z-index: -1;
    }

    .buddha-light.active {
      animation: halo-burst 10s ease-out forwards;
    }

    @keyframes halo-burst {
      0% {
        width: 0;
        height: 0;
        opacity: 0;
      }
      5% {
        opacity: 1;
      }
      25% {
        width: 900px;
        height: 900px;
        opacity: 1;
      }
      80% {
        opacity: 1;
      }
      100% {
        width: 1100px;
        height: 1100px;
        opacity: 0;
      }
    }

    .buddha {
      font-size: 12px;
      line-height: 1.2;
      white-space: pre;
      background: linear-gradient(135deg,
        #ff0080 0%,
        #ff00ff 15%,
        #8000ff 30%,
        #00d4ff 45%,
        #bf00ff 60%,
        #ffff00 75%,
        #ff8000 90%,
        #ff0080 100%);
      background-size: 200% 200%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      filter: drop-shadow(0 0 8px #ff00ff) drop-shadow(0 0 15px #00d4ff);
      animation: rainbow-flow 4s ease-in-out infinite;
      display: inline-block;
      text-align: left;
      user-select: none;
    }

    .title {
      font-size: 12px;
      margin-top: 12px;
      letter-spacing: 6px;
      background: linear-gradient(90deg,
        #bf00ff 0%,
        #00d4ff 25%,
        #ff00ff 50%,
        #ff0080 75%,
        #ffff00 100%);
      background-size: 200% 100%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      filter: drop-shadow(0 0 10px #00d4ff);
      animation: rainbow-slide 3s linear infinite;
      user-select: none;
    }

    #bg-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: -1;
      pointer-events: none;
    }

    #bg-container canvas {
      display: block;
    }

    @keyframes rainbow-flow {
      0% { background-position: 0% 0%; filter: drop-shadow(0 0 8px #ff0080) drop-shadow(0 0 15px #ff00ff); }
      25% { background-position: 50% 50%; filter: drop-shadow(0 0 8px #8000ff) drop-shadow(0 0 15px #00d4ff); }
      50% { background-position: 100% 100%; filter: drop-shadow(0 0 8px #bf00ff) drop-shadow(0 0 15px #ffff00); }
      75% { background-position: 50% 50%; filter: drop-shadow(0 0 8px #ff8000) drop-shadow(0 0 15px #ff0080); }
      100% { background-position: 0% 0%; filter: drop-shadow(0 0 8px #ff0080) drop-shadow(0 0 15px #ff00ff); }
    }

    @keyframes rainbow-slide {
      0% { background-position: 0% 50%; }
      100% { background-position: 200% 50%; }
    }

    .terminal {
      margin-top: 15px;
      text-align: center;
    }

    .wish-input {
      background: transparent;
      border: none;
      border-bottom: 1px solid rgba(0, 255, 136, 0.4);
      color: var(--neon);
      font-family: inherit;
      font-size: 14px;
      padding: 8px 0;
      width: 280px;
      outline: none;
      text-align: center;
      text-shadow: 0 0 8px var(--neon);
    }
    .wish-input:focus { border-color: #00ff88; }
    .wish-input::placeholder { color: #667; text-shadow: none; }

    .hint {
      margin-top: 18px;
      font-size: 11px;
      color: #667;
    }

    .amount-inline {
      background: transparent;
      border: none;
      border-bottom: 1px dashed #556;
      color: #667;
      font-family: inherit;
      font-size: 11px;
      width: 28px;
      text-align: center;
      outline: none;
    }
    .amount-inline:focus { color: var(--gold); border-color: var(--gold); }

    .amount-select {
      display: flex;
      justify-content: center;
      gap: 16px;
      margin-top: 16px;
    }

    .amount-opt {
      color: #556;
      cursor: pointer;
      padding: 4px 8px;
      transition: all 0.2s;
      font-size: 11px;
    }

    .amount-opt:hover {
      color: var(--gold);
      text-shadow: 0 0 10px var(--gold), 0 0 20px rgba(255, 170, 0, 0.4);
    }

    .amount-opt.selected {
      color: var(--gold);
      text-shadow: 0 0 8px var(--gold), 0 0 15px rgba(255, 170, 0, 0.3);
    }

    .ascii-btn {
      margin-top: 18px;
      background: transparent;
      border: none;
      color: var(--neon);
      font-family: inherit;
      font-size: 13px;
      cursor: pointer;
      text-shadow: 0 0 10px var(--neon);
      transition: all 0.3s;
      padding: 0;
    }
    .ascii-btn:hover { text-shadow: 0 0 20px var(--neon), 0 0 30px var(--neon); }
    .ascii-btn:disabled { opacity: 0.3; cursor: not-allowed; text-shadow: none; }

    .btn {
      padding: 6px 12px;
      background: transparent;
      border: 1px solid var(--neon);
      color: var(--neon);
      font-family: inherit;
      font-size: 10px;
      cursor: pointer;
      border-radius: 0;
      transition: all 0.3s;
    }

    .btn:hover { background: rgba(191, 0, 255, 0.1); box-shadow: 0 0 15px rgba(191, 0, 255, 0.3); }
    .btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .btn.gold { border-color: var(--gold); color: var(--gold); }
    .btn.gold:hover { background: rgba(255, 170, 0, 0.1); box-shadow: 0 0 15px rgba(255, 170, 0, 0.3); }

  </style>
</head>
<body>
  <div id="bg-container"></div>
  <div class="header-left">
    <div class="chain-switcher" id="chain-switcher">
      <span class="chain-arrow" id="chain-prev">Â«</span>
      <span class="chain-name" id="chain-name">base</span>
      <span class="chain-arrow" id="chain-next">Â»</span>
    </div>
  </div>

  <div class="header-right">
    <div class="wallet-status" id="wallet-status">
      <span class="wallet-addr" id="wallet">connect wallet</span>
    </div>
  </div>

  <div class="msg-queue" id="msg-queue"></div>

  <!-- Wallet Selection Modal -->
  <div class="wallet-modal" id="wallet-modal">
    <div class="wallet-modal-content">
      <div class="wallet-modal-title">:: SELECT WALLET ::</div>
      <div class="wallet-option" id="opt-metamask" data-wallet="metamask">
        <span class="wallet-icon">ğŸ¦Š</span>
        <span>MetaMask</span>
      </div>
      <div class="wallet-option" id="opt-phantom" data-wallet="phantom">
        <span class="wallet-icon">ğŸ‘»</span>
        <span>Phantom</span>
      </div>
      <div class="wallet-modal-divider"></div>
      <div class="network-toggle">
        <span class="network-opt selected" data-network="mainnet">[ mainnet ]</span>
        <span class="network-opt" data-network="testnet">[ testnet ]</span>
      </div>
    </div>
  </div>

  <div class="container">
    <div class="buddha-wrapper">
      <canvas id="dharma-canvas" width="900" height="900"></canvas>
      <canvas id="ripple-canvas" width="900" height="900"></canvas>
      <canvas id="lotus-canvas" width="900" height="900"></canvas>
      <div class="buddha-light" id="buddha-light"></div>
      <pre class="buddha">                  _oo0oo_
                 o8888888o
                 88" . "88
                (|  -_-  |)
                 0\  =  /0
               ___/`---'\___
             .' \\|     |// '.
            / \\|||  :  |||// \
           / _||||| -:- |||||- \
          |   | \\\  -  /// |   |
          | \_|  ''\---/''  |_/ |
          \  .-\__  '-'  ___/-. /
        ___'. .'  /--.--\  `. .'___
     ."" '<  `.___\_<|>_/___.'  >' "".
    | | :  `- \`.;`\ _ /`;.`/ - ` : | |
    \  \ `_.   \_ __\ /__ _/   .-` /  /
=====`-.____`.___ \_____/___.-`___.-'=====
                  `=---='

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
          ä½›ç¥–ä¿ä½‘         æ°¸ç„¡ BUG
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</pre>
    </div>
    <div class="title">C Y B E R _ B U D D H A</div>

    <div class="terminal">
      <div class="wish-line">
        <input type="text" class="wish-input" id="wish" placeholder="ping buddha..." maxlength="100">
      </div>
      <div class="amount-select" id="amount-select">
        <span class="amount-opt" data-amount="1.024">$1.024</span>
        <span class="amount-opt selected" data-amount="10.24">$10.24</span>
        <span class="amount-opt" data-amount="102.4">$102.4</span>
        <span class="amount-opt" data-amount="1024">$1024</span>
      </div>
      <button class="ascii-btn" id="action">:: BLESS ::</button>
    </div>
  </div>

  <!-- PixiJS for GPU-accelerated rendering -->
  <script src="https://pixijs.download/v8.6.6/pixi.min.js"></script>

  <script type="module">
    import { createWalletClient, custom, getAddress } from 'https://esm.sh/viem@2.21.0';

    const NETWORK_CONFIG = {
      'base': { chainId: 8453 },
      'base-sepolia': { chainId: 84532 },
      'polygon': { chainId: 137 },
      'polygon-amoy': { chainId: 80002 },
      'avalanche': { chainId: 43114 },
      'avalanche-fuji': { chainId: 43113 },
    };

    const MAINNET_CHAINS = ['base', 'polygon', 'avalanche'];
    const TESTNET_CHAINS = ['base-sepolia', 'polygon-amoy', 'avalanche-fuji'];
    const AMOUNTS = [1.024, 10.24, 102.4, 1024];
    const state = { address: null, chainId: null, config: null, chainIndex: 0, selectedAmount: 10.24, walletType: null, networkType: 'mainnet' };

    function getChains() {
      return state.networkType === 'mainnet' ? MAINNET_CHAINS : TESTNET_CHAINS;
    }
    const $ = id => document.getElementById(id);
    const dom = {
      wallet: $('wallet'),
      walletStatus: $('wallet-status'),
      wish: $('wish'),
      amountSelect: $('amount-select'),
      action: $('action'),
      buddhaLight: $('buddha-light'),
      dharmaCanvas: $('dharma-canvas'),
      rippleCanvas: $('ripple-canvas'),
      lotusCanvas: $('lotus-canvas'),
      chainName: $('chain-name'),
      chainPrev: $('chain-prev'),
      chainNext: $('chain-next'),
      chainSwitcher: $('chain-switcher'),
      msgQueue: $('msg-queue'),
      walletModal: $('wallet-modal'),
      optMetamask: $('opt-metamask'),
      optPhantom: $('opt-phantom'),
      networkToggle: document.querySelectorAll('.network-opt')
    };

    // Wallet providers
    function getProvider(walletType) {
      if (walletType === 'metamask') {
        return window.ethereum?.isMetaMask ? window.ethereum : null;
      } else if (walletType === 'phantom') {
        return window.phantom?.ethereum;
      }
      return null;
    }

    function detectWallets() {
      const hasMetaMask = !!window.ethereum?.isMetaMask;
      const hasPhantom = !!window.phantom?.ethereum;

      dom.optMetamask.classList.toggle('disabled', !hasMetaMask);
      dom.optPhantom.classList.toggle('disabled', !hasPhantom);

      if (!hasMetaMask) dom.optMetamask.title = 'MetaMask not installed';
      if (!hasPhantom) dom.optPhantom.title = 'Phantom not installed';
    }

    function showWalletModal() {
      detectWallets();
      dom.walletModal.classList.add('show');
    }

    function hideWalletModal() {
      dom.walletModal.classList.remove('show');
    }

    // Amount selection
    dom.amountSelect.addEventListener('click', (e) => {
      const opt = e.target.closest('.amount-opt');
      if (!opt) return;
      dom.amountSelect.querySelectorAll('.amount-opt').forEach(el => el.classList.remove('selected'));
      opt.classList.add('selected');
      state.selectedAmount = parseFloat(opt.dataset.amount);
    });

    // Message queue system
    const MSG_MAX = 5;
    const MSG_LIFETIME = 6000; // ms
    const messages = [];

    function addMessage(text, type = '') {
      const msg = { text, type, id: Date.now(), el: null };
      messages.unshift(msg);

      // Remove oldest if over limit
      while (messages.length > MSG_MAX) {
        const old = messages.pop();
        if (old.el) old.el.remove();
      }

      renderMessages();

      // Auto fade out
      setTimeout(() => {
        const idx = messages.findIndex(m => m.id === msg.id);
        if (idx !== -1) {
          messages.splice(idx, 1);
          renderMessages();
        }
      }, MSG_LIFETIME);
    }

    function renderMessages() {
      dom.msgQueue.innerHTML = '';
      messages.forEach((msg, i) => {
        const el = document.createElement('div');
        el.className = `msg-item ${msg.type}`;
        // Newer = brighter, older = dimmer
        const opacity = 1 - (i / MSG_MAX) * 0.6;
        el.style.opacity = opacity;
        el.textContent = msg.text;
        msg.el = el;
        dom.msgQueue.appendChild(el);
      });
    }

    // æ³•è½® - æ¢µæ–‡/ä½›ç»æ–‡å­—æ—‹è½¬
    const dharmaCtx = dom.dharmaCanvas.getContext('2d');
    const DHARMA_SIZE = 900;
    const DHARMA_CENTER = DHARMA_SIZE / 2;
    let dharmaAnimating = false;
    let dharmaStart = 0;
    const DHARMA_DURATION = 10000;

    // æ¢µæ–‡/ä½›ç»æ–‡å­—
    const SUTRAS = [
      'à¥', 'à¤®à¤£à¤¿', 'à¤ªà¤¦à¥à¤®à¥‡', 'à¤¹à¥‚à¤',
      'å—ç„¡é˜¿å½Œé™€ä½›', 'èˆ¬è‹¥æ³¢ç¾…èœœå¤š', 'è‰²å³æ˜¯ç©º', 'ç©ºå³æ˜¯è‰²',
      'è§€è‡ªåœ¨', 'è©æ', 'æ¶…æ§ƒ', 'å› æœ', 'è¼ªè¿´', 'è§£è„«',
      'æ…ˆæ‚²', 'æ™ºæ…§', 'åŠŸå¾·', 'ç¦å ±', 'æ¥­éšœ', 'æ¸…æ·¨',
      'å”µ', 'å˜›', 'å‘¢', 'å­', 'å’ª', 'å½',
      'à¤…', 'à¤†', 'à¤‡', 'à¤ˆ', 'à¤‰', 'à¤Š',
      'å', 'â˜¸', 'à¿•', 'à¿–',
    ];

    // ç”Ÿæˆå¤šåœˆæ–‡å­— - å†…å°å¤–å¤§
    const dharmaRings = [];
    const ringCount = 6;
    for (let r = 0; r < ringCount; r++) {
      const radius = 80 + r * 55; // å†…å¤–åœˆé—´éš™æ›´å°
      const fontSize = 14 + r * 4; // å†…åœˆ14pxï¼Œå¤–åœˆ34px
      const circumference = 2 * Math.PI * radius;
      const charCount = Math.floor(circumference / (fontSize * 3.2)); // åŒåœˆå†…é—´è·æ›´å¤§é¿å…é‡å 
      const speed = (r % 2 === 0 ? 1 : -1) * (0.15 + r * 0.03);
      const ring = { radius, speed, fontSize, chars: [] };
      for (let i = 0; i < charCount; i++) {
        ring.chars.push({
          text: SUTRAS[Math.floor(Math.random() * SUTRAS.length)],
          angle: (i / charCount) * Math.PI * 2,
          opacity: 0.4 + Math.random() * 0.4
        });
      }
      dharmaRings.push(ring);
    }

    function drawDharmaWheel(timestamp) {
      const elapsed = timestamp - dharmaStart;
      const progress = Math.min(elapsed / DHARMA_DURATION, 1);

      // Fade in then out
      let opacity = 1;
      if (progress < 0.1) {
        opacity = progress / 0.1;
      } else if (progress > 0.8) {
        opacity = (1 - progress) / 0.2;
      }

      dharmaCtx.clearRect(0, 0, DHARMA_SIZE, DHARMA_SIZE);

      if (opacity <= 0) {
        dharmaAnimating = false;
        return;
      }

      dharmaCtx.save();
      dharmaCtx.globalAlpha = opacity;

      // ç»˜åˆ¶æ¯åœˆæ–‡å­—
      for (const ring of dharmaRings) {
        const rotation = (elapsed / 1000) * ring.speed;

        for (const char of ring.chars) {
          const angle = char.angle + rotation;
          const x = DHARMA_CENTER + Math.cos(angle) * ring.radius;
          const y = DHARMA_CENTER + Math.sin(angle) * ring.radius;

          dharmaCtx.save();
          dharmaCtx.translate(x, y);
          dharmaCtx.rotate(angle + Math.PI / 2);

          // é‡‘è‰²å‘å…‰æ–‡å­— - ç»†ä½“å¤é£å­—ä½“
          dharmaCtx.font = `300 ${ring.fontSize}px "ZCOOL XiaoWei", "Noto Serif SC", serif`;
          dharmaCtx.textAlign = 'center';
          dharmaCtx.textBaseline = 'middle';
          dharmaCtx.fillStyle = `rgba(200, 160, 50, ${char.opacity * 0.6})`;
          dharmaCtx.shadowColor = 'rgba(180, 140, 30, 0.4)';
          dharmaCtx.shadowBlur = 5;
          dharmaCtx.fillText(char.text, 0, 0);

          dharmaCtx.restore();
        }
      }

      dharmaCtx.restore();

      if (dharmaAnimating) {
        requestAnimationFrame(drawDharmaWheel);
      }
    }

    function startDharmaWheel(level) {
      // level: 1=å°, 2=ä¸­, 3=å¤§, 4=æœ€å¤§
      // é‡æ–°éšæœºæ–‡å­—ï¼Œæ ¹æ®ç­‰çº§è°ƒæ•´äº®åº¦
      const brightnessMultiplier = 0.6 + level * 0.15;
      for (const ring of dharmaRings) {
        for (const char of ring.chars) {
          char.text = SUTRAS[Math.floor(Math.random() * SUTRAS.length)];
          char.opacity = (0.3 + Math.random() * 0.5) * brightnessMultiplier;
        }
      }
      dharmaAnimating = true;
      dharmaStart = performance.now();
      requestAnimationFrame(drawDharmaWheel);
    }

    // ========== æ¢µéŸ³æ³¢çº¹ ==========
    const rippleCtx = dom.rippleCanvas.getContext('2d');
    const RIPPLE_SIZE = 900;
    const RIPPLE_CENTER = RIPPLE_SIZE / 2;
    let rippleAnimating = false;
    let rippleStart = 0;
    const RIPPLE_DURATION = 10000;

    // æ³¢çº¹å’’è¯­
    const MANTRAS = ['à¥', 'à¤®à¤£à¤¿', 'à¤ªà¤¦à¥à¤®à¥‡', 'à¤¹à¥‚à¤', 'å”µ', 'å˜›', 'å‘¢', 'å­', 'å’ª', 'å½'];

    // æ³¢çº¹æ•°æ®
    let ripples = [];

    function initRipples() {
      ripples = [];
      // åˆ›å»º5åœˆæ³¢çº¹ï¼Œæ¯åœˆæºå¸¦å’’è¯­
      for (let i = 0; i < 5; i++) {
        const mantraCount = 6 + i * 2; // å†…åœˆå°‘ï¼Œå¤–åœˆå¤š
        const chars = [];
        for (let j = 0; j < mantraCount; j++) {
          chars.push({
            text: MANTRAS[Math.floor(Math.random() * MANTRAS.length)],
            angle: (j / mantraCount) * Math.PI * 2 + Math.random() * 0.2,
            opacity: 0.5 + Math.random() * 0.3
          });
        }
        ripples.push({
          startRadius: 50,
          maxRadius: 350,
          delay: i * 400, // æ¯åœˆå»¶è¿Ÿ
          chars,
          speed: 0.08 + Math.random() * 0.02
        });
      }
    }

    function drawRipples(timestamp) {
      const elapsed = timestamp - rippleStart;
      rippleCtx.clearRect(0, 0, RIPPLE_SIZE, RIPPLE_SIZE);

      let anyActive = false;

      for (const ripple of ripples) {
        const rippleTime = elapsed - ripple.delay;
        if (rippleTime < 0) {
          anyActive = true;
          continue;
        }
        if (rippleTime > RIPPLE_DURATION) continue;

        anyActive = true;
        const progress = rippleTime / RIPPLE_DURATION;

        // æ³¢çº¹æ‰©æ•£
        const radius = ripple.startRadius + (ripple.maxRadius - ripple.startRadius) * progress;

        // æ·¡å…¥æ·¡å‡º
        let alpha = 1;
        if (progress < 0.1) alpha = progress / 0.1;
        else if (progress > 0.7) alpha = (1 - progress) / 0.3;

        // ç»˜åˆ¶æ³¢çº¹åœ†ç¯
        rippleCtx.beginPath();
        rippleCtx.arc(RIPPLE_CENTER, RIPPLE_CENTER, radius, 0, Math.PI * 2);
        rippleCtx.strokeStyle = `rgba(180, 150, 80, ${alpha * 0.3})`;
        rippleCtx.lineWidth = 2;
        rippleCtx.stroke();

        // ç»˜åˆ¶æ³¢çº¹ä¸Šçš„å’’è¯­
        const rotation = (rippleTime / 1000) * ripple.speed;
        for (const char of ripple.chars) {
          const angle = char.angle + rotation;
          const x = RIPPLE_CENTER + Math.cos(angle) * radius;
          const y = RIPPLE_CENTER + Math.sin(angle) * radius;

          rippleCtx.save();
          rippleCtx.translate(x, y);
          rippleCtx.rotate(angle + Math.PI / 2);

          const fontSize = 14 + progress * 6; // éšæ‰©æ•£å˜å¤§
          rippleCtx.font = `300 ${fontSize}px "ZCOOL XiaoWei", serif`;
          rippleCtx.textAlign = 'center';
          rippleCtx.textBaseline = 'middle';
          rippleCtx.fillStyle = `rgba(200, 170, 80, ${alpha * char.opacity})`;
          rippleCtx.shadowColor = 'rgba(180, 140, 30, 0.3)';
          rippleCtx.shadowBlur = 4;
          rippleCtx.fillText(char.text, 0, 0);

          rippleCtx.restore();
        }
      }

      if (anyActive && rippleAnimating) {
        requestAnimationFrame(drawRipples);
      } else {
        rippleAnimating = false;
      }
    }

    function startRipples(level) {
      initRipples();
      // æ ¹æ®ç­‰çº§è°ƒæ•´äº®åº¦
      const brightnessMultiplier = 0.7 + level * 0.1;
      for (const ripple of ripples) {
        for (const char of ripple.chars) {
          char.opacity *= brightnessMultiplier;
        }
      }
      rippleAnimating = true;
      rippleStart = performance.now();
      requestAnimationFrame(drawRipples);
    }

    // ========== è²èŠ±ç»½æ”¾ ==========
    const lotusCtx = dom.lotusCanvas.getContext('2d');
    const LOTUS_SIZE = 900;
    const LOTUS_CENTER = LOTUS_SIZE / 2;
    let lotusAnimating = false;
    let lotusStart = 0;
    const LOTUS_DURATION = 10000;

    // æ¢µæ–‡ç§å­å­—
    const LOTUS_CHARS = ['à¥', 'à¤…', 'à¤†', 'à¤‡', 'à¤ˆ', 'à¤‰', 'à¤Š', 'å', 'â˜¸'];

    // èŠ±ç“£æ•°æ®
    let lotusPetals = [];

    function initLotus() {
      lotusPetals = [];
      const petalCount = 12; // 12ç“£è²èŠ±
      for (let i = 0; i < petalCount; i++) {
        lotusPetals.push({
          angle: (i / petalCount) * Math.PI * 2,
          char: LOTUS_CHARS[Math.floor(Math.random() * LOTUS_CHARS.length)],
          length: 280 + Math.random() * 70,
          width: 80 + Math.random() * 30,
          delay: Math.random() * 500,
          opacity: 0.5 + Math.random() * 0.3
        });
      }
    }

    function drawLotus(timestamp) {
      const elapsed = timestamp - lotusStart;
      lotusCtx.clearRect(0, 0, LOTUS_SIZE, LOTUS_SIZE);

      if (elapsed > LOTUS_DURATION) {
        lotusAnimating = false;
        return;
      }

      const overallProgress = elapsed / LOTUS_DURATION;

      // æ•´ä½“æ·¡å…¥æ·¡å‡º
      let masterAlpha = 1;
      if (overallProgress < 0.1) masterAlpha = overallProgress / 0.1;
      else if (overallProgress > 0.8) masterAlpha = (1 - overallProgress) / 0.2;

      // è²èŠ±æ—‹è½¬å±•å¼€ï¼ˆæ›´å¹³æ»‘çš„è¿‡æ¸¡ï¼‰
      const rotationDuration = 6000;
      const rotationProgress = Math.min(elapsed / rotationDuration, 1);
      // ä½¿ç”¨æ›´å¹³æ»‘çš„ç¼“åŠ¨
      const easedRotation = 1 - Math.pow(1 - rotationProgress, 2);
      const rotation = easedRotation * Math.PI * 0.4 + (elapsed / 1000) * 0.02;

      lotusCtx.save();
      lotusCtx.translate(LOTUS_CENTER, LOTUS_CENTER);
      lotusCtx.rotate(rotation);

      for (const petal of lotusPetals) {
        const petalTime = elapsed - petal.delay;
        if (petalTime < 0) continue;

        // æ—‹è½¬å±•å¼€ï¼šæ›´æ…¢æ›´è‡ªç„¶
        const expandDuration = 5000;
        const bloomProgress = Math.min(petalTime / expandDuration, 1);

        // æ›´å¹³æ»‘çš„ç¼“åŠ¨å‡½æ•° (ease-in-out)
        const eased = bloomProgress < 0.5
          ? 2 * bloomProgress * bloomProgress
          : 1 - Math.pow(-2 * bloomProgress + 2, 2) / 2;

        // èŠ±ç“£è½»å¾®å‘¼å¸
        const breath = 1 + Math.sin(elapsed / 1200 + petal.angle) * 0.025;
        const length = petal.length * eased * breath;
        const width = petal.width * eased * breath;

        lotusCtx.save();
        lotusCtx.rotate(petal.angle);

        // ç»˜åˆ¶èŠ±ç“£è½®å»“ (è´å¡å°”æ›²çº¿)
        lotusCtx.beginPath();
        lotusCtx.moveTo(0, 0);
        lotusCtx.bezierCurveTo(
          width * 0.5, -length * 0.3,
          width * 0.8, -length * 0.7,
          0, -length
        );
        lotusCtx.bezierCurveTo(
          -width * 0.8, -length * 0.7,
          -width * 0.5, -length * 0.3,
          0, 0
        );

        // èŠ±ç“£æ¸å˜å¡«å…… (æ›´æ·¡)
        const gradient = lotusCtx.createLinearGradient(0, 0, 0, -length);
        gradient.addColorStop(0, `rgba(255, 180, 200, ${masterAlpha * petal.opacity * 0.25})`);
        gradient.addColorStop(0.5, `rgba(255, 200, 180, ${masterAlpha * petal.opacity * 0.18})`);
        gradient.addColorStop(1, `rgba(255, 220, 200, ${masterAlpha * petal.opacity * 0.08})`);

        lotusCtx.fillStyle = gradient;
        lotusCtx.shadowColor = 'rgba(255, 150, 180, 0.15)';
        lotusCtx.shadowBlur = 6;
        lotusCtx.fill();

        // èŠ±ç“£è¾¹ç¼˜
        lotusCtx.strokeStyle = `rgba(255, 180, 150, ${masterAlpha * petal.opacity * 0.3})`;
        lotusCtx.lineWidth = 1;
        lotusCtx.stroke();

        // èŠ±ç“£ä¸Šçš„æ¢µæ–‡
        if (bloomProgress > 0.5) {
          const charAlpha = (bloomProgress - 0.5) * 2;
          lotusCtx.font = '300 24px "ZCOOL XiaoWei", serif';
          lotusCtx.textAlign = 'center';
          lotusCtx.textBaseline = 'middle';
          lotusCtx.fillStyle = `rgba(200, 150, 100, ${masterAlpha * charAlpha * petal.opacity * 0.6})`;
          lotusCtx.shadowColor = 'rgba(180, 120, 60, 0.2)';
          lotusCtx.shadowBlur = 2;
          lotusCtx.fillText(petal.char, 0, -length * 0.5);
        }

        lotusCtx.restore();
      }

      // è²èŠ±ä¸­å¿ƒ
      const centerGlow = lotusCtx.createRadialGradient(0, 0, 0, 0, 0, 60);
      centerGlow.addColorStop(0, `rgba(255, 220, 150, ${masterAlpha * 0.35})`);
      centerGlow.addColorStop(0.5, `rgba(255, 200, 100, ${masterAlpha * 0.18})`);
      centerGlow.addColorStop(1, 'transparent');
      lotusCtx.fillStyle = centerGlow;
      lotusCtx.beginPath();
      lotusCtx.arc(0, 0, 60, 0, Math.PI * 2);
      lotusCtx.fill();

      // ä¸­å¿ƒ à¥ å­—
      lotusCtx.font = '300 42px "ZCOOL XiaoWei", serif';
      lotusCtx.textAlign = 'center';
      lotusCtx.textBaseline = 'middle';
      lotusCtx.fillStyle = `rgba(200, 150, 50, ${masterAlpha * 0.5})`;
      lotusCtx.shadowColor = 'rgba(180, 120, 30, 0.5)';
      lotusCtx.shadowBlur = 6;
      lotusCtx.fillText('à¥', 0, 0);

      lotusCtx.restore();

      if (lotusAnimating) {
        requestAnimationFrame(drawLotus);
      }
    }

    function startLotus(level) {
      initLotus();
      // æ ¹æ®ç­‰çº§è°ƒæ•´äº®åº¦
      const brightnessMultiplier = 0.7 + level * 0.1;
      for (const petal of lotusPetals) {
        petal.opacity *= brightnessMultiplier;
      }
      lotusAnimating = true;
      lotusStart = performance.now();
      requestAnimationFrame(drawLotus);
    }

    // æ ¹æ®é‡‘é¢è§¦å‘ä¸åŒç‰¹æ•ˆï¼ˆç‹¬ç«‹ï¼‰
    // $1.024 = ä½›å…‰
    // $10.24 = æ³¢çº¹
    // $102.4 = è²èŠ±ç»½æ”¾
    // $1024 = æ³•è½® + èƒŒæ™¯å˜ä½›ç»
    function triggerEffect(amount) {
      if (amount >= 1024) {
        // æ³•è½®
        startDharmaWheel(4);
      } else if (amount >= 102.4) {
        // è²èŠ±ç»½æ”¾
        startLotus(3);
      } else if (amount >= 10.24) {
        // æ³¢çº¹
        startRipples(2);
      } else {
        // ä½›å…‰
        dom.buddhaLight.classList.remove('active');
        void dom.buddhaLight.offsetWidth;
        dom.buddhaLight.classList.add('active');
      }
    }

    async function fetchConfig() {
      return (await fetch('/api/wish')).json();
    }

    async function makeWish(amount, content, network) {
      console.log('makeWish called:', { amount, content, network });

      const res = await fetch('/api/wish', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ amount, content, network }),
      });

      console.log('Initial response status:', res.status);

      if (res.status !== 402) {
        if (res.ok) return res.json();
        const err = await res.json();
        console.error('Initial request failed:', err);
        throw new Error(err.error?.message || 'Request failed');
      }

      const data = await res.json();
      console.log('402 response:', data);
      const { accepts } = data;
      if (!accepts?.[0]) throw new Error('No payment requirements');

      console.log('Creating payment auth for:', accepts[0]);
      const payment = await createPaymentAuth(accepts[0]);
      console.log('Payment auth created:', payment);

      const payRes = await fetch('/api/wish', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json', 'X-PAYMENT': btoa(JSON.stringify(payment)) },
        body: JSON.stringify({ amount, content, network }),
      });

      console.log('Payment response status:', payRes.status);

      if (!payRes.ok) {
        const err = await payRes.json().catch(() => ({}));
        console.error('Payment failed:', err);
        // Translate error codes to user-friendly messages
        const errorMessages = {
          'insufficient_funds': 'insufficient USDC balance',
          'invalid_signature': 'signature verification failed',
          'expired': 'payment authorization expired',
          'already_used': 'payment already processed',
          'invalid_amount': 'invalid payment amount',
        };
        const errorCode = err.error || '';
        const friendlyMsg = errorMessages[errorCode] || err.error?.message || `payment failed (${payRes.status})`;
        throw new Error(friendlyMsg);
      }
      return payRes.json();
    }

    async function connectWallet(walletType) {
      const provider = getProvider(walletType);
      if (!provider) throw new Error(`${walletType} not installed`);

      const accounts = await provider.request({ method: 'eth_requestAccounts' });
      state.address = accounts[0];
      state.chainId = parseInt(await provider.request({ method: 'eth_chainId' }), 16);
      state.walletType = walletType;
      setupWalletListeners(provider);
    }

    // å°è¯•æ¢å¤å·²è¿æ¥çš„é’±åŒ…ï¼ˆä¸å¼¹çª—ï¼‰
    async function tryRestoreWallet() {
      // Try MetaMask first, then Phantom
      for (const walletType of ['metamask', 'phantom']) {
        const provider = getProvider(walletType);
        if (!provider) continue;

        try {
          const accounts = await provider.request({ method: 'eth_accounts' });
          if (accounts.length > 0) {
            state.address = accounts[0];
            state.chainId = parseInt(await provider.request({ method: 'eth_chainId' }), 16);
            state.walletType = walletType;
            setupWalletListeners(provider);
            updateUI();
            return;
          }
        } catch (e) {
          console.log(`Failed to restore ${walletType}:`, e);
        }
      }
    }

    function setupWalletListeners(provider) {
      provider.removeAllListeners?.('accountsChanged');
      provider.removeAllListeners?.('chainChanged');
      provider.on('accountsChanged', accs => {
        state.address = accs[0] || null;
        if (!accs[0]) state.walletType = null;
        updateUI();
      });
      provider.on('chainChanged', () => location.reload());
    }

    function disconnectWallet() {
      state.address = null;
      state.chainId = null;
      state.walletType = null;
      updateUI();
    }

    async function createPaymentAuth(req) {
      try {
        console.log('createPaymentAuth req:', req);
        const { asset, payTo, maxAmountRequired, extra, network, maxTimeoutSeconds } = req;
        const provider = getProvider(state.walletType);
        if (!provider) throw new Error('Wallet not connected');

        const nonce = '0x' + [...crypto.getRandomValues(new Uint8Array(32))].map(b => b.toString(16).padStart(2, '0')).join('');
        const now = Math.floor(Date.now() / 1000);
        const validAfter = BigInt(now - 600);
        const validBefore = BigInt(now + (maxTimeoutSeconds || 3600));
        const chainId = NETWORK_CONFIG[network]?.chainId || state.chainId;

        console.log('Chain check:', { currentChainId: state.chainId, requiredChainId: chainId, network });

        if (state.chainId !== chainId) {
          console.log('Switching chain to:', chainId);
          await provider.request({ method: 'wallet_switchEthereumChain', params: [{ chainId: `0x${chainId.toString(16)}` }] });
          state.chainId = chainId;
        }

        const walletClient = createWalletClient({ chain: { id: chainId, name: network }, transport: custom(provider) });
        const from = getAddress(state.address), to = getAddress(payTo);

        console.log('Signing typed data:', { from, to, value: maxAmountRequired, asset, chainId });

        const signature = await walletClient.signTypedData({
          account: from,
          domain: { name: extra?.name || 'USDC', version: extra?.version || '2', chainId, verifyingContract: getAddress(asset) },
          types: { TransferWithAuthorization: [
            { name: 'from', type: 'address' }, { name: 'to', type: 'address' }, { name: 'value', type: 'uint256' },
            { name: 'validAfter', type: 'uint256' }, { name: 'validBefore', type: 'uint256' }, { name: 'nonce', type: 'bytes32' },
          ]},
          primaryType: 'TransferWithAuthorization',
          message: { from, to, value: BigInt(maxAmountRequired), validAfter, validBefore, nonce },
        });

        console.log('Signature obtained:', signature);

        return {
          x402Version: 1, scheme: 'exact', network,
          payload: { signature, authorization: { from, to, value: maxAmountRequired, validAfter: validAfter.toString(), validBefore: validBefore.toString(), nonce } },
        };
      } catch (err) {
        console.error('createPaymentAuth error:', err);
        throw err;
      }
    }

    function updateUI() {
      if (state.address) {
        dom.wallet.textContent = `${state.address.slice(0, 6)}...${state.address.slice(-4)}`;
        dom.walletStatus.classList.add('connected');
        dom.chainSwitcher.classList.add('connected');
      } else {
        dom.wallet.textContent = 'connect wallet';
        dom.walletStatus.classList.remove('connected');
        dom.chainSwitcher.classList.remove('connected');
      }
    }

    // Chain switcher
    function updateChainDisplay() {
      const chains = getChains();
      dom.chainName.textContent = chains[state.chainIndex];
    }

    dom.chainPrev.addEventListener('click', () => {
      const chains = getChains();
      state.chainIndex = (state.chainIndex - 1 + chains.length) % chains.length;
      updateChainDisplay();
      addMessage(`switched to ${chains[state.chainIndex]}`);
    });

    dom.chainNext.addEventListener('click', () => {
      const chains = getChains();
      state.chainIndex = (state.chainIndex + 1) % chains.length;
      updateChainDisplay();
      addMessage(`switched to ${chains[state.chainIndex]}`);
    });

    // Wallet connect/disconnect on header click
    // Wallet status click - show modal or disconnect
    dom.walletStatus.addEventListener('click', () => {
      if (state.address) {
        disconnectWallet();
        addMessage('wallet disconnected');
      } else {
        showWalletModal();
      }
    });

    // Wallet modal close (click outside)
    dom.walletModal.addEventListener('click', (e) => {
      if (e.target === dom.walletModal) hideWalletModal();
    });

    // Network toggle in modal
    dom.networkToggle.forEach(opt => {
      opt.addEventListener('click', () => {
        dom.networkToggle.forEach(el => el.classList.remove('selected'));
        opt.classList.add('selected');
        state.networkType = opt.dataset.network;
        state.chainIndex = 0; // Reset to first chain
      });
    });

    // Wallet option click
    document.querySelectorAll('.wallet-option').forEach(opt => {
      opt.addEventListener('click', async () => {
        if (opt.classList.contains('disabled')) return;

        const walletType = opt.dataset.wallet;
        hideWalletModal();

        try {
          addMessage(`connecting ${walletType}...`);
          await connectWallet(walletType);
          updateUI();
          updateChainDisplay();
          addMessage(`${walletType} connected (${state.networkType})`, 'success');
        } catch (e) {
          addMessage(e.message, 'error');
        }
      });
    });

    // Make wish on action button click
    dom.action.addEventListener('click', async () => {
      const amount = state.selectedAmount;

      if (!state.address) {
        addMessage('please connect wallet first', 'error');
        return;
      }

      try {
        dom.action.disabled = true;
        addMessage(`preparing $${amount} payment...`);
        const network = getChains()[state.chainIndex];
        const result = await makeWish(amount, dom.wish.value || undefined, network);
        console.log('Payment success, triggering effect for amount:', amount, result);
        addMessage(result.message, 'success');
        triggerEffect(amount);
        startCoinFlip(amount);
        dom.wish.value = '';
      } catch (e) {
        console.error('Payment error:', e);
        addMessage(e.message, 'error');
      }
      finally { dom.action.disabled = false; }
    });

    // PixiJS GPU åŠ é€ŸèƒŒæ™¯
    const BG_SUTRAS = [
      'à¥', 'å', 'â˜¸', 'à¿•', 'à¿–',
      'ä½›', 'ç¦…', 'ç©º', 'æ…§', 'æ‚Ÿ', 'ç¼˜', 'å–„', 'ç¦', 'å¾·', 'é™', 'å‡€', 'è§‰', 'é“', 'å¿ƒ', 'å¿µ', 'å®š', 'æ™º', 'æ˜', 'æ³•', 'æœ',
      'è©æ', 'æ¶…æ§ƒ', 'èˆ¬è‹¥', 'å› æœ', 'è½®å›', 'è§£è„±', 'æ…ˆæ‚²', 'åŠŸå¾·', 'æ¸…å‡€', 'åœ†æ»¡', 'å¦‚æ¥', 'çœŸå¦‚', 'æ— æˆ‘', 'æ­£å¿µ', 'è§‰æ‚Ÿ',
      'é˜¿å¼¥é™€ä½›', 'è‰²å³æ˜¯ç©º', 'ç©ºå³æ˜¯è‰²', 'æ˜å¿ƒè§æ€§', 'è¿”ç’å½’çœŸ', 'éšç¼˜è‡ªåœ¨', 'å¿ƒæ— æŒ‚ç¢', 'ä¸€å¿µæˆä½›', 'å›å¤´æ˜¯å²¸', 'æ”¾ä¸‹æ‰§å¿µ',
      'å”µå˜›å‘¢å­å’ªå½', 'å—æ— é˜¿å¼¥é™€ä½›', 'è¯¸æ³•æ— æˆ‘', 'è¯¸è¡Œæ— å¸¸', 'æ¶…æ§ƒå¯‚é™', 'ä¸€åˆ‡çš†ç©º', 'ç¼˜èµ·æ€§ç©º', 'åº”æ— æ‰€ä½'
    ];

    let pixiApp = null;
    let textSprites = [];
    let animating = false;
    let animationStart = 0;
    const ANIMATION_DURATION = 10;
    const MAX_DELAY = 3;

    async function initPixi() {
      const container = document.getElementById('bg-container');

      // åˆ›å»º PixiJS åº”ç”¨
      pixiApp = new PIXI.Application();
      await pixiApp.init({
        width: window.innerWidth,
        height: window.innerHeight,
        backgroundAlpha: 0,
        antialias: true,
        resolution: window.devicePixelRatio || 1,
        autoDensity: true,
      });

      container.appendChild(pixiApp.canvas);

      // ç”Ÿæˆæ–‡å­—ç²¾çµ
      const textStyle = new PIXI.TextStyle({
        fontFamily: 'Courier New',
        fontSize: 12,
        fill: 0xffaa00,
      });

      // æµ‹é‡ x402 å®½åº¦
      const measureText = new PIXI.Text({ text: 'x402', style: textStyle });
      const textWidth = measureText.width;
      measureText.destroy();

      let x = 0, y = 0;
      const lineHeight = 12 * 1.6;

      while (y < window.innerHeight + lineHeight) {
        x = (Math.random() - 0.5) * 50;
        while (x < window.innerWidth + 50) {
          const spacing = Math.random() * 30;
          const baseOpacity = 0.22 * (0.25 + Math.random() * 0.75);

          const sprite = new PIXI.Text({
            text: 'x402',
            style: new PIXI.TextStyle({
              fontFamily: 'Courier New',
              fontSize: 12,
              fill: 0xffaa00,
            })
          });

          sprite.x = x + (Math.random() - 0.5) * 12;
          sprite.y = y + (Math.random() - 0.5) * 10;
          sprite.alpha = baseOpacity;
          sprite.anchor.set(0.5, 0);

          // å­˜å‚¨é¢å¤–æ•°æ®
          sprite._data = {
            baseOpacity,
            delay: Math.random() * MAX_DELAY,
            is1024: Math.random() < 0.5,
            sutra: BG_SUTRAS[Math.floor(Math.random() * BG_SUTRAS.length)],
            originalText: 'x402'
          };

          pixiApp.stage.addChild(sprite);
          textSprites.push(sprite);

          x += textWidth + 4 + spacing;
        }
        y += lineHeight;
      }

      console.log('PixiJS sprites:', textSprites.length);

      // åŠ¨ç”»å¾ªç¯
      pixiApp.ticker.add(animationLoop);
    }

    function easeInOut(t) {
      return t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
    }

    function animationLoop() {
      if (!animating) return;

      const elapsed = (performance.now() - animationStart) / 1000;

      for (const sprite of textSprites) {
        const data = sprite._data;
        const itemTime = elapsed - data.delay;

        if (itemTime > 0 && itemTime < ANIMATION_DURATION) {
          const progress = easeInOut(itemTime / ANIMATION_DURATION);
          const angle = progress * Math.PI * 2;
          const scaleX = Math.cos(angle);

          sprite.scale.x = Math.abs(scaleX);
          const brightness = 1 + 2 * Math.sin(progress * Math.PI);
          sprite.alpha = data.baseOpacity * brightness;

          // ç¿»è½¬åˆ°èƒŒé¢æ—¶åˆ‡æ¢æ–‡å­—
          if (scaleX < 0 && sprite.text === data.originalText) {
            sprite.text = data.targetText;
          } else if (scaleX >= 0 && sprite.text !== data.originalText && itemTime < ANIMATION_DURATION / 2) {
            sprite.text = data.originalText;
          }
        } else if (itemTime >= ANIMATION_DURATION) {
          sprite.scale.x = 1;
          sprite.alpha = data.baseOpacity;
          sprite.text = data.targetText;
        }
      }

      // åŠ¨ç”»ç»“æŸ
      if (elapsed >= ANIMATION_DURATION + MAX_DELAY) {
        animating = false;
        // æœ€ç»ˆçŠ¶æ€
        for (const sprite of textSprites) {
          sprite.scale.x = 1;
          sprite.alpha = sprite._data.baseOpacity;
          sprite.text = sprite._data.targetText;
          sprite._data.originalText = sprite._data.targetText;
        }
      }
    }

    function startCoinFlip(amount = 10.24) {
      // è®¾ç½®ç›®æ ‡æ–‡å­—
      for (const sprite of textSprites) {
        const data = sprite._data;
        data.delay = Math.random() * MAX_DELAY;
        data.is1024 = Math.random() < 0.5;
        data.sutra = BG_SUTRAS[Math.floor(Math.random() * BG_SUTRAS.length)];

        if (amount >= 1024) {
          data.targetText = `  ${data.sutra}  `;
        } else {
          data.targetText = data.is1024 ? '1024' : 'x402';
        }
      }

      animating = true;
      animationStart = performance.now();
    }

    // åˆå§‹åŒ– PixiJS
    initPixi();

    // resize å¤„ç†
    window.addEventListener('resize', () => {
      if (pixiApp) {
        pixiApp.renderer.resize(window.innerWidth, window.innerHeight);
      }
    });

    (async () => {
      try {
        state.config = await fetchConfig();
        await tryRestoreWallet();
        updateUI();
        updateChainDisplay();
      } catch { addMessage('failed to load config', 'error'); }
    })();
  </script>
</body>
</html>
